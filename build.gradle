import groovy.json.*
import java.util.regex.Pattern
import java.util.regex.Matcher

// Create a build directory first.
task prepareDirs {
  doLast {
    mkdir 'build'
  }
}

task buildChangelog {

  dependsOn prepareDirs

  doLast {
    def outputText = ""
    def stringsFile = new File("./build/changelog.md")

    def openHABMilestone = project.hasProperty('openhabMilestone') ? project.property('openhabMilestone') : System.env.OPENHAB_MILESTONE
    def legacyMilestone = project.hasProperty('openhabLegacyMilestone') ? project.property('openhabLegacyMilestone') : System.env.OPENHAB_LEGACY_MILESTONE

    openHABMilestone = openHABMilestone ?: "2.5"
    legacyMilestone = legacyMilestone ?: "1.14.0"

    def fullChangeList = []

    // Define a list of categories and the repositories to search in
    def categories = [
      [
        "type" : "core",
        "orgName" : "openhab",
        "milestone" : "${openHABMilestone}",
        "repos" : [
          [
            "name" : "openhab-distro"
          ],[
            "name" : "openhab-core"
          ]
        ]
      ],[
        "type" : "2.x add-ons",
        "orgName" : "openhab",
        "milestone" : "${openHABMilestone}",
        "repos" : [
          [
            "name" : "openhab-addons",
          ],[
            "name" : "openhab-webui",
          ],[
            "name" : "org.openhab.binding.zigbee",
            "addonName" : "Zigbee"
          ],[
            "name" : "org.openhab.binding.zwave",
            "addonName" : "ZWave"
          ]
        ]
      ],[
        "type" : "1.x legacy add-ons",
        "orgName" : "openhab",
        "milestone" : "${legacyMilestone}",
        "repos" : [
          [
            "name" : "openhab1-addons"
          ]
        ]
      ]
    ]

    // Iterate through each category
    categories.each { category ->

      def pullRequests
      def milestone = category.milestone
      def milestoneString = ""
      if (milestone != "") {milestoneString = "%20milestone:%22${milestone}%22"}
      def orgName = category.orgName

      // Iterate through each repository
      category.repos.each { repo ->

        def curlURL = ""
        def labelString = ""
        def repoName = repo.name
        def addonName = repo.addonName

        def searchesLeft = 1
        def pageNumber = 1
        def pageString = ""

        // GitHub allows only 100 results at a time, so loop through multiple pages.
        while (searchesLeft > 0) {
          curlURL = "https://api.github.com/search/issues?q=repo:${orgName}/${repoName}%20is:pr%20is:merged${milestoneString}${labelString}&per_page=100${pageString}"
          print "Parsing: ${orgName}/${repoName} (Milestone ${milestone}, Page ${pageNumber}"
          def curlOutput = new ByteArrayOutputStream()
          exec {
            commandLine "curl", "${curlURL}"
            standardOutput = curlOutput
            errorOutput = new ByteArrayOutputStream()
          }

          // Wait a while to avoid hitting a rate limit.
          exec {
            commandLine "sleep", "10"
          }
          def jsonSlurper = new JsonSlurper()
          def searchResults = jsonSlurper.parseText(curlOutput.toString())

          searchResults.items.each{pullRequest ->
            def pullTitle = pullRequest.title
            def pullNumber = pullRequest.number
            def pullURL = pullRequest.html_url
            def pullCategory = category.type
            def pullAddon = ""
            def docsURL = ""
            def pullType = ""
            def addonType = ""

            // Assign the addon name, filter Core into its own category.
            if (category.type == "core") {
              addonName = "Core"
            } else {
              Pattern pattern = Pattern.compile("\\[(.*?)\\](.*)")
              Matcher matcher = pattern.matcher(pullTitle)

              if (matcher.find()) {
                pullAddon = matcher.group(1)
                pullTitle = matcher.group(2)
              } else if (repo.addonName) {
                pullAddon = repo.addonName
              } else {
                pullAddon = "Misc"
              }
            }

            // Assign the pull request type (bug, enhancement etc)
            pullRequest.labels.each { label ->
              switch(label.name.toLowerCase())
              {
                case "bug":
                  pullType="bug"
                  break
                case "enhancement":
                  pullType="enhancement"
                  break
                case ~/^new(.+)/:
                  if (repoName == "openhab-core") {
                    pullType="feature"
                  } else {

                    // New addons should have their correct name displayed with a link to documentation
                    def addonTypeURL
                    pullType = "new"
                    addonType = Matcher.lastMatcher[0][1].trim().capitalize()
                    if (addonType == "Contribution"){ addonType = "Binding" }
                    if (addonType == "Transform") { addonType = "Transformation" }
                    if ((addonType != "Voice") && (addonType != "Persistence")) {
                      addonTypeURL = (addonType + "s").toLowerCase()
                    } else {
                      addonTypeURL = addonType.toLowerCase()
                    }
                    docsURL = "https://www.openhab.org/addons/${addonTypeURL}/${pullAddon}/"

                    // Search the openHAB website for the addon's full name.
                    def url = docsURL.toURL()
                    Pattern htmlPattern = Pattern.compile(".*<title>(.*) - .* \\| openHAB<\\/title>")
                    try {
                      Matcher htmlMatcher = htmlPattern.matcher(url.text)
                      if (htmlMatcher.find()) {
                        pullAddon = htmlMatcher.group(1)
                      }
                    } catch (FileNotFoundException e) {
                      println "  Warning: New contribution PR #${pullNumber} does not have a correct [name]..."
                    }
                  }
                  break
              }
            }

            // Add PR to full changelog list to be formatted later
            if (pullType != "") {
            fullChangeList << [
              "category" : "${pullCategory}",
              "type" : "${pullType}",
              "addon" : "${pullAddon}",
              "description" : "${pullTitle}",
              "number" : "${pullNumber}",
              "url" : "${pullURL}",
              "docs" : "${docsURL}",
              "class" : "${addonType}"
            ]
            }
          }

          // If there"s more pages to go, search these too
          if (pageString == "") {
            def resultsFound = searchResults.total_count
            println ", Pull Requests Found: ${resultsFound})"
            if (resultsFound > 100) {
              searchesLeft = Math.ceil(resultsFound/100)
            }
          } else {
            println ")"
          }
          searchesLeft = searchesLeft - 1
          pageNumber = pageNumber + 1
          pageString = "&page=${pageNumber}"
        }
      }
    }

    // Format a MarkDown Changelog, new addons first
    outputText = outputText + "## openHAB ${openHABMilestone} Changelog\n\n"
    outputText = outputText + "### New Add-ons\n\n"
    outputText = outputText + "The following add-ons are newly introduced with the ${openHABMilestone} release:\n\n"
    outputText = outputText + "| Add-on | Type | Issue |\n"
    outputText = outputText + "|-|-|-|\n"

    def sortedList = fullChangeList.findAll{it.type == "new"}.sort{it.addon.toLowerCase()}

    sortedList.each {
      outputText = outputText + "| [**${it.addon}**](${it.docs}) | ${it.class} | [#${it.number}](${it.url}) |\n"
    }

    // Iterate through the same categories as above for patches
    outputText = outputText + "\nThe following improvements were also made:\n"
    categories.each{category ->

      def categoryName = category.type

      // Format Core differently to addons
      if (categoryName == "Core") {
        outputText = outputText + "\n### Runtime\n\n"
        outputText = outputText + "| Type | Issue | Change |\n"
        outputText = outputText + "|-|-|-|\n"
      } else {
      outputText = outputText + "\n### ${categoryName}\n\n"
      outputText = outputText + "| Add-on | Type | Issue | Change |\n"
      outputText = outputText + "|-|-|-|-|\n"
      }
      sortedList = fullChangeList.findAll{it.type != "new"}.findAll{it.category == "${categoryName.toLowerCase()}"}.sort{it.type}.reverse().sort{it.addon.toLowerCase()}

      def previousType = ""
      def previousAddon = ""
      sortedList.each {
        def addonText = ""
        def typeText = ""

        if (it.addon.toLowerCase() != previousAddon) {
          addonText = "**" + "${it.addon}" + "**"
          previousType = ""
          if (categoryName == "Core") {
            outputText = outputText + "| | | |\n"
          } else {
            outputText = outputText + "| | | | |\n"
          }
        }
        if (it.type != previousType) {
          switch (it.type){
            case "bug":
              typeText = "Bug Fixes"
              break
            case "enhancement":
              typeText = "Enhancements"
              break
            case "feature":
              typeText = "New Feature"
              break
          }
          typeText = "*" + "${typeText}" + "*"
        }

        if (categoryName == "Core") {
          outputText = outputText + "| ${typeText} | [${it.number}](${it.url}) | ${it.description} |\n"
        } else {
          outputText = outputText + "| ${addonText} | ${typeText} | [${it.number}](${it.url}) | ${it.description} |\n"
        }
        previousAddon = it.addon.toLowerCase()
        previousType = it.type
      }
    }
    stringsFile.text = outputText
  }
}
